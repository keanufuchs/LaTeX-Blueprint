\chapter{Implementierung}
\ihead{Implementierung}

\section{Überblick}

Die Implementierung von \textbf{XL Fabric} setzt die in Kapitel~\ref{chap:konzeptionierung} beschriebene Architektur konsequent um. Die Kernkomponenten – \ac{CLI} mit Click, Excel-Parser mit pandas/openpyxl, zweistufige Pydantic-Validierung, Konvertierungslogik in \texttt{XltoAciConfig}, \ac{YAML}-Export mit PyYAML sowie zentrales Logging – arbeiten in einer klaren Pipeline zusammen und stellen durch die zweifache Validierung sowohl die Qualität der Eingabedaten als auch die Terraform-Konformität der Ausgabe sicher.

Zur Verdeutlichung der Softwarearchitektur zeigt Abbildung~\ref{fig:klassendiagramm} die wichtigsten Klassen und ihre Beziehungen:

\begin{figure}[ht]
    \centering
    % HIER MERMAID DIAGRAMM EINFÜGEN
    \includegraphics[width=\textwidth]{bilder/klassendiagramm.png}
    \caption{Vereinfachtes Klassendiagramm der Kernkomponenten}
    \label{fig:klassendiagramm}
\end{figure}

\section{Command-Line-Interface}
\label{sec:cli-implementierung}

Die \ac{CLI} bildet das Hauptinterface für Benutzerinteraktionen und wurde mit der Click-Bibliothek implementiert. Im Zentrum steht der Befehl \texttt{generate}, der die gesamte Verarbeitungskette von Excel-Import bis \ac{YAML}-Export orchestriert – mit den Optionen \texttt{--inputdir/-i} (Standard: \texttt{./files/input}) und \texttt{--outputdir/-o} (Standard: \texttt{./files/output}) sowie dem Flag \texttt{--terraform/-t} für den Terraform-Export. Ein vorbereitetes Flag \texttt{--ansible/-a} existiert im Code, wurde jedoch nicht implementiert. Die Implementierung iteriert über alle Excel-Dateien im Input-Verzeichnis, führt sie zu einem zusammenhängenden Datenset zusammen und ruft die Terraform-Generator-Funktion auf (vollständige Implementierung siehe Anhang, Codebeispiel~\ref{code:cli_main}).

\section{Excel-Parser}
\label{sec:excel-parser-impl}

Der Excel-Parser nutzt openpyxl zum Laden der Workbook-Struktur und pandas zur Datenmanipulation. Die Funktion \texttt{parse\_excelfile} iteriert über alle Worksheets, behandelt dabei spezielle Layouts unterschiedlich – standard-vertikale Sheets mit Header in der ersten Zeile werden direkt in DataFrames überführt, während Sheets im Pascal-Design (z.B. \texttt{ACI\_Fabric}) eine eigene Import-Routine durchlaufen. Leere Zeilen und Spalten werden automatisch bereinigt, die bereinigten Daten in Python-Dictionaries konvertiert und mehrere Excel-Dateien können sequenziell verarbeitet und zusammengeführt werden (Details siehe Anhang, Codebeispiel~\ref{code:excel_parser}).

\section{Input-Validierung mit Pydantic}
\label{sec:input-validierung-impl}

Die erste Validierungsebene basiert auf Pydantic-Modellen unter \path{xl_fabric.models.xlsx} und deckt alle relevanten \ac{ACI}-Objekte ab: Tenants, \ac{VRF}s, Bridge Domains, Application Profiles, \ac{EPG}s, Contracts und Filter, Domains, \ac{VLAN}-Pools sowie Interface Policies. Nach dem Parsing wird jedes Sheet auf das entsprechende Modell gemappt (z.B. Sheet \texttt{\ac{BD}} → Modell \texttt{\ac{BD}}) und instanziiert – Pydantic prüft dabei automatisch Pflichtfelder wie \texttt{Name}, \texttt{Tenant} und \texttt{\ac{VRF}}, konvertiert Typen und validiert Formate. Ein repräsentatives Beispiel ist das Bridge-Domain-Modell mit Feldern in PascalCase-Notation, primär String-Typen und optionalen Parametern (siehe Anhang, Codebeispiel~\ref{code:bd_model} und \ref{code:bd_input_model}). Bei ValidationErrors wird der Prozess sofort abgebrochen und Pydantic liefert detaillierte Fehlermeldungen mit Position, Feldname und konkreter Fehlerursache \cite[vgl.][]{pydantic_welcome_2025}.

\section{Konvertierung in Terraform-Struktur}
\label{sec:konvertierung-impl}

Die Klasse \texttt{XltoAciConfig} orchestriert die Transformation der validierten Excel-Daten in die Terraform-Modulstruktur der \ac{NaC}-Module. Für jedes \ac{ACI}-Objekt werden relevante Felder extrahiert, Referenzen aufgelöst (z.B. \ac{EPG} → \ac{BD} → \ac{VRF} → Tenant), die Modulstruktur abgebildet und Terraform-spezifische Metadaten ergänzt. Ein Beispiel ist die Bridge-Domain-Konvertierung: Komma-separierte Subnet-Strings aus Excel werden in Listen von Subnet-Objekten transformiert, String-Werte wie \texttt{"true"} in Booleans konvertiert, PascalCase-Feldnamen in snake\_case überführt und Dictionary-Keys nach dem Schema \texttt{Name\_Tenant} generiert. Die konvertierten Objekte werden direkt in die Output-Modelle überführt, wodurch die zweite Validierungsschicht greift (exemplarischer Code siehe Anhang, Codebeispiel~\ref{code:converter}).

\section{Output-Validierung}
\label{sec:output-validierung-impl}

Die zweite Validierungsebene nutzt Pydantic-Modelle unter \path{xl_fabric.models.aciconfig}, die auf Terraform-Konformität optimiert sind. Im Gegensatz zu den Input-Modellen verwenden Output-Modelle snake\_case-Feldnamen, komplexe Python-Typen wie \texttt{ipaddress.IPv4Interface} für \ac{IP}-Adressen und \texttt{bool} statt String-Werten sowie verschachtelte Sub-Modelle (z.B. \texttt{Subnet} innerhalb von \texttt{BridgeDomain}). Für die Terraform-Module, die ihre Konfiguration als Dictionaries erwarten, kommen \texttt{RootModel}-basierte Container zum Einsatz, die Collections von \ac{ACI}-Objekten als validierte Dictionary-Strukturen abbilden. Field-Aliase mappen Excel-Feldnamen automatisch auf Terraform-Parameter, Cross-References zwischen \ac{EPG}s, Bridge Domains, \ac{VRF}s und Contracts werden streng geprüft und die Modulkonformität sichergestellt (Beispiel siehe Anhang, Codebeispiel~\ref{code:bd_output_model}). Fehler in dieser Phase deuten auf Programmfehler in der Konvertierungslogik hin.

\section{\ac{YAML}-Export}
\label{sec:yaml-export-impl}

Der \texttt{AciConfigExporter} erzeugt strukturierte \ac{YAML}-Dateien mithilfe des Moduls PyYAML, wobei die Organisation nach Geltungsbereich erfolgt: Fabric-weite Konfigurationen wie \ac{VLAN}-Pools, Domains, Interface Policies und Attachment Entity Profiles werden unter \texttt{files/output/terraform/fabric/} abgelegt, während Tenant-spezifische Objekte wie \ac{VRF}s, Bridge Domains, Application Profiles, \ac{EPG}s, Contracts und Filter pro Tenant in separaten Verzeichnissen unter \texttt{files/output/terraform/tenants/[tenant]/} organisiert werden. Die Formatierung folgt den YAML-Spezifikationen für konsistente Einrückung (2 Leerzeichen), Block-Style für Listen, leere Strings statt \texttt{null}-Werten und \ac{UTF}-8-Encoding \cite[vgl.][]{pyyamlorg_pyyamlorgwikipyyamldocumentation_2020} – vor jedem Export wird das Output-Verzeichnis bereinigt, wobei \texttt{.gitkeep}-Dateien erhalten bleiben (vollständige Implementierung siehe Anhang, Codebeispiel~\ref{code:yaml_export}).

\section{Logging und Fehlerbehandlung}
\label{sec:logging-impl}

Ein zentrales Logging-System begleitet alle Verarbeitungsschritte mit konfigurierbaren Log-Leveln von DEBUG für Entwicklungsinformationen über INFO für Statusmeldungen, WARNING für nicht-kritische Probleme bis ERROR für Abbruchfehler und CRITICAL für Systemfehler. Die Konfiguration erfolgt über \texttt{config/logging.json} mit Console-Handler für stdout/stderr-Ausgabe und File-Handler für Persistierung unter \texttt{logs/xlfabric.log}, strukturierter Formatierung mit Zeitstempel, Modulname, Level und Nachricht sowie optionaler Log-Rotation. Validierungsfehler werden besonders aufbereitet: Pydantic ValidationErrors werden abgefangen, mit Excel-Zeilen- und Spaltennummern angereichert, strukturiert geloggt und als benutzerfreundliche Meldungen ausgegeben, wobei Fehlertyp, Position, Erwartung versus Realität und konkrete Korrekturhinweise enthalten sind (Beispiele siehe Anhang, Codebeispiele~\ref{code:logger_config} und \ref{code:error_handling}).

\section{Zusammenfassung}

Die Implementierung folgt konsequent der Pipeline-Architektur: Excel-Import → Input-Validierung → Konvertierung → Output-Validierung → \ac{YAML}-Export. Die Kombination aus Pydantic für zweistufige Validierung, pandas/openpyxl für robustes Excel-Parsing, PyYAML für strukturierten Export und Click für intuitive \ac{CLI}-Bedienung liefert ein produktionsreifes Tool mit hoher Datenqualität, klarer Fehlerbehandlung und guter Erweiterbarkeit um weitere \ac{ACI}-Objekte.